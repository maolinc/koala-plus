// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: koala.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AuthorityClient is the client API for Authority service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthorityClient interface {
	Enforce(ctx context.Context, in *PolicyReq, opts ...grpc.CallOption) (*BoolRep, error)
	BatchEnforce(ctx context.Context, in *RulesReq, opts ...grpc.CallOption) (*BoolRep, error)
	UserPermsVerify(ctx context.Context, in *UserPermsVerifyReq, opts ...grpc.CallOption) (*BoolRep, error)
	RoleBind(ctx context.Context, in *RoleBindReq, opts ...grpc.CallOption) (*BoolRep, error)
}

type authorityClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthorityClient(cc grpc.ClientConnInterface) AuthorityClient {
	return &authorityClient{cc}
}

func (c *authorityClient) Enforce(ctx context.Context, in *PolicyReq, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, "/koala.Authority/Enforce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityClient) BatchEnforce(ctx context.Context, in *RulesReq, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, "/koala.Authority/BatchEnforce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityClient) UserPermsVerify(ctx context.Context, in *UserPermsVerifyReq, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, "/koala.Authority/UserPermsVerify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityClient) RoleBind(ctx context.Context, in *RoleBindReq, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, "/koala.Authority/RoleBind", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthorityServer is the server API for Authority service.
// All implementations must embed UnimplementedAuthorityServer
// for forward compatibility
type AuthorityServer interface {
	Enforce(context.Context, *PolicyReq) (*BoolRep, error)
	BatchEnforce(context.Context, *RulesReq) (*BoolRep, error)
	UserPermsVerify(context.Context, *UserPermsVerifyReq) (*BoolRep, error)
	RoleBind(context.Context, *RoleBindReq) (*BoolRep, error)
	mustEmbedUnimplementedAuthorityServer()
}

// UnimplementedAuthorityServer must be embedded to have forward compatible implementations.
type UnimplementedAuthorityServer struct {
}

func (UnimplementedAuthorityServer) Enforce(context.Context, *PolicyReq) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enforce not implemented")
}
func (UnimplementedAuthorityServer) BatchEnforce(context.Context, *RulesReq) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchEnforce not implemented")
}
func (UnimplementedAuthorityServer) UserPermsVerify(context.Context, *UserPermsVerifyReq) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserPermsVerify not implemented")
}
func (UnimplementedAuthorityServer) RoleBind(context.Context, *RoleBindReq) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleBind not implemented")
}
func (UnimplementedAuthorityServer) mustEmbedUnimplementedAuthorityServer() {}

// UnsafeAuthorityServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthorityServer will
// result in compilation errors.
type UnsafeAuthorityServer interface {
	mustEmbedUnimplementedAuthorityServer()
}

func RegisterAuthorityServer(s grpc.ServiceRegistrar, srv AuthorityServer) {
	s.RegisterService(&Authority_ServiceDesc, srv)
}

func _Authority_Enforce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).Enforce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Authority/Enforce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).Enforce(ctx, req.(*PolicyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authority_BatchEnforce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RulesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).BatchEnforce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Authority/BatchEnforce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).BatchEnforce(ctx, req.(*RulesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authority_UserPermsVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserPermsVerifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).UserPermsVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Authority/UserPermsVerify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).UserPermsVerify(ctx, req.(*UserPermsVerifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authority_RoleBind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleBindReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).RoleBind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Authority/RoleBind",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).RoleBind(ctx, req.(*RoleBindReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Authority_ServiceDesc is the grpc.ServiceDesc for Authority service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Authority_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "koala.Authority",
	HandlerType: (*AuthorityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Enforce",
			Handler:    _Authority_Enforce_Handler,
		},
		{
			MethodName: "BatchEnforce",
			Handler:    _Authority_BatchEnforce_Handler,
		},
		{
			MethodName: "UserPermsVerify",
			Handler:    _Authority_UserPermsVerify_Handler,
		},
		{
			MethodName: "RoleBind",
			Handler:    _Authority_RoleBind_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "koala.proto",
}

// AccountClient is the client API for Account service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccountClient interface {
	CreateAccount(ctx context.Context, in *AccountReq, opts ...grpc.CallOption) (*EmptyResp, error)
	UpdateAccount(ctx context.Context, in *AccountReq, opts ...grpc.CallOption) (*EmptyResp, error)
	DeleteAccounts(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error)
	PageAccount(ctx context.Context, in *AccountQueryReq, opts ...grpc.CallOption) (*AccountListResp, error)
	UpdatePassword(ctx context.Context, in *UpdatePasswordReq, opts ...grpc.CallOption) (*EmptyResp, error)
	ResetPassword(ctx context.Context, in *ResetPasswordReq, opts ...grpc.CallOption) (*EmptyResp, error)
	RegisterUser(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*RegisterResp, error)
	LoginUser(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error)
	GetUserInfo(ctx context.Context, in *GetUserInfoReq, opts ...grpc.CallOption) (*GetUserInfoResp, error)
	GenerateToken(ctx context.Context, in *GenerateTokenReq, opts ...grpc.CallOption) (*GenerateTokenResp, error)
}

type accountClient struct {
	cc grpc.ClientConnInterface
}

func NewAccountClient(cc grpc.ClientConnInterface) AccountClient {
	return &accountClient{cc}
}

func (c *accountClient) CreateAccount(ctx context.Context, in *AccountReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Account/CreateAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) UpdateAccount(ctx context.Context, in *AccountReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Account/UpdateAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) DeleteAccounts(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Account/DeleteAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) PageAccount(ctx context.Context, in *AccountQueryReq, opts ...grpc.CallOption) (*AccountListResp, error) {
	out := new(AccountListResp)
	err := c.cc.Invoke(ctx, "/koala.Account/PageAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) UpdatePassword(ctx context.Context, in *UpdatePasswordReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Account/UpdatePassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) ResetPassword(ctx context.Context, in *ResetPasswordReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Account/ResetPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) RegisterUser(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*RegisterResp, error) {
	out := new(RegisterResp)
	err := c.cc.Invoke(ctx, "/koala.Account/RegisterUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) LoginUser(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error) {
	out := new(LoginResp)
	err := c.cc.Invoke(ctx, "/koala.Account/LoginUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) GetUserInfo(ctx context.Context, in *GetUserInfoReq, opts ...grpc.CallOption) (*GetUserInfoResp, error) {
	out := new(GetUserInfoResp)
	err := c.cc.Invoke(ctx, "/koala.Account/getUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountClient) GenerateToken(ctx context.Context, in *GenerateTokenReq, opts ...grpc.CallOption) (*GenerateTokenResp, error) {
	out := new(GenerateTokenResp)
	err := c.cc.Invoke(ctx, "/koala.Account/generateToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountServer is the server API for Account service.
// All implementations must embed UnimplementedAccountServer
// for forward compatibility
type AccountServer interface {
	CreateAccount(context.Context, *AccountReq) (*EmptyResp, error)
	UpdateAccount(context.Context, *AccountReq) (*EmptyResp, error)
	DeleteAccounts(context.Context, *DeletesReq) (*EmptyResp, error)
	PageAccount(context.Context, *AccountQueryReq) (*AccountListResp, error)
	UpdatePassword(context.Context, *UpdatePasswordReq) (*EmptyResp, error)
	ResetPassword(context.Context, *ResetPasswordReq) (*EmptyResp, error)
	RegisterUser(context.Context, *RegisterReq) (*RegisterResp, error)
	LoginUser(context.Context, *LoginReq) (*LoginResp, error)
	GetUserInfo(context.Context, *GetUserInfoReq) (*GetUserInfoResp, error)
	GenerateToken(context.Context, *GenerateTokenReq) (*GenerateTokenResp, error)
	mustEmbedUnimplementedAccountServer()
}

// UnimplementedAccountServer must be embedded to have forward compatible implementations.
type UnimplementedAccountServer struct {
}

func (UnimplementedAccountServer) CreateAccount(context.Context, *AccountReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccount not implemented")
}
func (UnimplementedAccountServer) UpdateAccount(context.Context, *AccountReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAccount not implemented")
}
func (UnimplementedAccountServer) DeleteAccounts(context.Context, *DeletesReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccounts not implemented")
}
func (UnimplementedAccountServer) PageAccount(context.Context, *AccountQueryReq) (*AccountListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PageAccount not implemented")
}
func (UnimplementedAccountServer) UpdatePassword(context.Context, *UpdatePasswordReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePassword not implemented")
}
func (UnimplementedAccountServer) ResetPassword(context.Context, *ResetPasswordReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedAccountServer) RegisterUser(context.Context, *RegisterReq) (*RegisterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterUser not implemented")
}
func (UnimplementedAccountServer) LoginUser(context.Context, *LoginReq) (*LoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginUser not implemented")
}
func (UnimplementedAccountServer) GetUserInfo(context.Context, *GetUserInfoReq) (*GetUserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedAccountServer) GenerateToken(context.Context, *GenerateTokenReq) (*GenerateTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateToken not implemented")
}
func (UnimplementedAccountServer) mustEmbedUnimplementedAccountServer() {}

// UnsafeAccountServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccountServer will
// result in compilation errors.
type UnsafeAccountServer interface {
	mustEmbedUnimplementedAccountServer()
}

func RegisterAccountServer(s grpc.ServiceRegistrar, srv AccountServer) {
	s.RegisterService(&Account_ServiceDesc, srv)
}

func _Account_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Account/CreateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).CreateAccount(ctx, req.(*AccountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_UpdateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).UpdateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Account/UpdateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).UpdateAccount(ctx, req.(*AccountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_DeleteAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).DeleteAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Account/DeleteAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).DeleteAccounts(ctx, req.(*DeletesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_PageAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountQueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).PageAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Account/PageAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).PageAccount(ctx, req.(*AccountQueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Account/UpdatePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).UpdatePassword(ctx, req.(*UpdatePasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Account/ResetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).ResetPassword(ctx, req.(*ResetPasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Account/RegisterUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).RegisterUser(ctx, req.(*RegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_LoginUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).LoginUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Account/LoginUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).LoginUser(ctx, req.(*LoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Account/getUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).GetUserInfo(ctx, req.(*GetUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Account_GenerateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServer).GenerateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Account/generateToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServer).GenerateToken(ctx, req.(*GenerateTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Account_ServiceDesc is the grpc.ServiceDesc for Account service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Account_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "koala.Account",
	HandlerType: (*AccountServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAccount",
			Handler:    _Account_CreateAccount_Handler,
		},
		{
			MethodName: "UpdateAccount",
			Handler:    _Account_UpdateAccount_Handler,
		},
		{
			MethodName: "DeleteAccounts",
			Handler:    _Account_DeleteAccounts_Handler,
		},
		{
			MethodName: "PageAccount",
			Handler:    _Account_PageAccount_Handler,
		},
		{
			MethodName: "UpdatePassword",
			Handler:    _Account_UpdatePassword_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _Account_ResetPassword_Handler,
		},
		{
			MethodName: "RegisterUser",
			Handler:    _Account_RegisterUser_Handler,
		},
		{
			MethodName: "LoginUser",
			Handler:    _Account_LoginUser_Handler,
		},
		{
			MethodName: "getUserInfo",
			Handler:    _Account_GetUserInfo_Handler,
		},
		{
			MethodName: "generateToken",
			Handler:    _Account_GenerateToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "koala.proto",
}

// ApplicationClient is the client API for Application service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApplicationClient interface {
	CreateSysApplication(ctx context.Context, in *CreateSysApplicationReq, opts ...grpc.CallOption) (*CreateSysApplicationResp, error)
	UpdateSysApplication(ctx context.Context, in *UpdateSysApplicationReq, opts ...grpc.CallOption) (*UpdateSysApplicationResp, error)
	DeleteSysApplication(ctx context.Context, in *DeleteSysApplicationReq, opts ...grpc.CallOption) (*DeleteSysApplicationResp, error)
	DetailSysApplication(ctx context.Context, in *DetailSysApplicationReq, opts ...grpc.CallOption) (*DetailSysApplicationResp, error)
	PageSysApplication(ctx context.Context, in *SearchSysApplicationReq, opts ...grpc.CallOption) (*SearchSysApplicationResp, error)
}

type applicationClient struct {
	cc grpc.ClientConnInterface
}

func NewApplicationClient(cc grpc.ClientConnInterface) ApplicationClient {
	return &applicationClient{cc}
}

func (c *applicationClient) CreateSysApplication(ctx context.Context, in *CreateSysApplicationReq, opts ...grpc.CallOption) (*CreateSysApplicationResp, error) {
	out := new(CreateSysApplicationResp)
	err := c.cc.Invoke(ctx, "/koala.Application/CreateSysApplication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationClient) UpdateSysApplication(ctx context.Context, in *UpdateSysApplicationReq, opts ...grpc.CallOption) (*UpdateSysApplicationResp, error) {
	out := new(UpdateSysApplicationResp)
	err := c.cc.Invoke(ctx, "/koala.Application/UpdateSysApplication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationClient) DeleteSysApplication(ctx context.Context, in *DeleteSysApplicationReq, opts ...grpc.CallOption) (*DeleteSysApplicationResp, error) {
	out := new(DeleteSysApplicationResp)
	err := c.cc.Invoke(ctx, "/koala.Application/DeleteSysApplication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationClient) DetailSysApplication(ctx context.Context, in *DetailSysApplicationReq, opts ...grpc.CallOption) (*DetailSysApplicationResp, error) {
	out := new(DetailSysApplicationResp)
	err := c.cc.Invoke(ctx, "/koala.Application/DetailSysApplication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationClient) PageSysApplication(ctx context.Context, in *SearchSysApplicationReq, opts ...grpc.CallOption) (*SearchSysApplicationResp, error) {
	out := new(SearchSysApplicationResp)
	err := c.cc.Invoke(ctx, "/koala.Application/PageSysApplication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplicationServer is the server API for Application service.
// All implementations must embed UnimplementedApplicationServer
// for forward compatibility
type ApplicationServer interface {
	CreateSysApplication(context.Context, *CreateSysApplicationReq) (*CreateSysApplicationResp, error)
	UpdateSysApplication(context.Context, *UpdateSysApplicationReq) (*UpdateSysApplicationResp, error)
	DeleteSysApplication(context.Context, *DeleteSysApplicationReq) (*DeleteSysApplicationResp, error)
	DetailSysApplication(context.Context, *DetailSysApplicationReq) (*DetailSysApplicationResp, error)
	PageSysApplication(context.Context, *SearchSysApplicationReq) (*SearchSysApplicationResp, error)
	mustEmbedUnimplementedApplicationServer()
}

// UnimplementedApplicationServer must be embedded to have forward compatible implementations.
type UnimplementedApplicationServer struct {
}

func (UnimplementedApplicationServer) CreateSysApplication(context.Context, *CreateSysApplicationReq) (*CreateSysApplicationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSysApplication not implemented")
}
func (UnimplementedApplicationServer) UpdateSysApplication(context.Context, *UpdateSysApplicationReq) (*UpdateSysApplicationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSysApplication not implemented")
}
func (UnimplementedApplicationServer) DeleteSysApplication(context.Context, *DeleteSysApplicationReq) (*DeleteSysApplicationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSysApplication not implemented")
}
func (UnimplementedApplicationServer) DetailSysApplication(context.Context, *DetailSysApplicationReq) (*DetailSysApplicationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetailSysApplication not implemented")
}
func (UnimplementedApplicationServer) PageSysApplication(context.Context, *SearchSysApplicationReq) (*SearchSysApplicationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PageSysApplication not implemented")
}
func (UnimplementedApplicationServer) mustEmbedUnimplementedApplicationServer() {}

// UnsafeApplicationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApplicationServer will
// result in compilation errors.
type UnsafeApplicationServer interface {
	mustEmbedUnimplementedApplicationServer()
}

func RegisterApplicationServer(s grpc.ServiceRegistrar, srv ApplicationServer) {
	s.RegisterService(&Application_ServiceDesc, srv)
}

func _Application_CreateSysApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSysApplicationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationServer).CreateSysApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Application/CreateSysApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationServer).CreateSysApplication(ctx, req.(*CreateSysApplicationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Application_UpdateSysApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSysApplicationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationServer).UpdateSysApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Application/UpdateSysApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationServer).UpdateSysApplication(ctx, req.(*UpdateSysApplicationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Application_DeleteSysApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSysApplicationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationServer).DeleteSysApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Application/DeleteSysApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationServer).DeleteSysApplication(ctx, req.(*DeleteSysApplicationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Application_DetailSysApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetailSysApplicationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationServer).DetailSysApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Application/DetailSysApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationServer).DetailSysApplication(ctx, req.(*DetailSysApplicationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Application_PageSysApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchSysApplicationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationServer).PageSysApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Application/PageSysApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationServer).PageSysApplication(ctx, req.(*SearchSysApplicationReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Application_ServiceDesc is the grpc.ServiceDesc for Application service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Application_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "koala.Application",
	HandlerType: (*ApplicationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSysApplication",
			Handler:    _Application_CreateSysApplication_Handler,
		},
		{
			MethodName: "UpdateSysApplication",
			Handler:    _Application_UpdateSysApplication_Handler,
		},
		{
			MethodName: "DeleteSysApplication",
			Handler:    _Application_DeleteSysApplication_Handler,
		},
		{
			MethodName: "DetailSysApplication",
			Handler:    _Application_DetailSysApplication_Handler,
		},
		{
			MethodName: "PageSysApplication",
			Handler:    _Application_PageSysApplication_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "koala.proto",
}

// MenuClient is the client API for Menu service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuClient interface {
	CreateMenu(ctx context.Context, in *MenuReq, opts ...grpc.CallOption) (*EmptyResp, error)
	UpdateMenu(ctx context.Context, in *MenuReq, opts ...grpc.CallOption) (*EmptyResp, error)
	DeleteMenus(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error)
	GetMenuTree(ctx context.Context, in *MenuQueryReq, opts ...grpc.CallOption) (*MenusResp, error)
	GetUserMenuList(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*UserMenusResp, error)
	GetMenuForRole(ctx context.Context, in *PermsReq, opts ...grpc.CallOption) (*PermsResp, error)
}

type menuClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuClient(cc grpc.ClientConnInterface) MenuClient {
	return &menuClient{cc}
}

func (c *menuClient) CreateMenu(ctx context.Context, in *MenuReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Menu/CreateMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) UpdateMenu(ctx context.Context, in *MenuReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Menu/UpdateMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) DeleteMenus(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Menu/DeleteMenus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetMenuTree(ctx context.Context, in *MenuQueryReq, opts ...grpc.CallOption) (*MenusResp, error) {
	out := new(MenusResp)
	err := c.cc.Invoke(ctx, "/koala.Menu/GetMenuTree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetUserMenuList(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*UserMenusResp, error) {
	out := new(UserMenusResp)
	err := c.cc.Invoke(ctx, "/koala.Menu/GetUserMenuList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetMenuForRole(ctx context.Context, in *PermsReq, opts ...grpc.CallOption) (*PermsResp, error) {
	out := new(PermsResp)
	err := c.cc.Invoke(ctx, "/koala.Menu/GetMenuForRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServer is the server API for Menu service.
// All implementations must embed UnimplementedMenuServer
// for forward compatibility
type MenuServer interface {
	CreateMenu(context.Context, *MenuReq) (*EmptyResp, error)
	UpdateMenu(context.Context, *MenuReq) (*EmptyResp, error)
	DeleteMenus(context.Context, *DeletesReq) (*EmptyResp, error)
	GetMenuTree(context.Context, *MenuQueryReq) (*MenusResp, error)
	GetUserMenuList(context.Context, *UserReq) (*UserMenusResp, error)
	GetMenuForRole(context.Context, *PermsReq) (*PermsResp, error)
	mustEmbedUnimplementedMenuServer()
}

// UnimplementedMenuServer must be embedded to have forward compatible implementations.
type UnimplementedMenuServer struct {
}

func (UnimplementedMenuServer) CreateMenu(context.Context, *MenuReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMenu not implemented")
}
func (UnimplementedMenuServer) UpdateMenu(context.Context, *MenuReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenu not implemented")
}
func (UnimplementedMenuServer) DeleteMenus(context.Context, *DeletesReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMenus not implemented")
}
func (UnimplementedMenuServer) GetMenuTree(context.Context, *MenuQueryReq) (*MenusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuTree not implemented")
}
func (UnimplementedMenuServer) GetUserMenuList(context.Context, *UserReq) (*UserMenusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserMenuList not implemented")
}
func (UnimplementedMenuServer) GetMenuForRole(context.Context, *PermsReq) (*PermsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuForRole not implemented")
}
func (UnimplementedMenuServer) mustEmbedUnimplementedMenuServer() {}

// UnsafeMenuServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServer will
// result in compilation errors.
type UnsafeMenuServer interface {
	mustEmbedUnimplementedMenuServer()
}

func RegisterMenuServer(s grpc.ServiceRegistrar, srv MenuServer) {
	s.RegisterService(&Menu_ServiceDesc, srv)
}

func _Menu_CreateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).CreateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Menu/CreateMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).CreateMenu(ctx, req.(*MenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_UpdateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).UpdateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Menu/UpdateMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).UpdateMenu(ctx, req.(*MenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_DeleteMenus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).DeleteMenus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Menu/DeleteMenus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).DeleteMenus(ctx, req.(*DeletesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetMenuTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuQueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetMenuTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Menu/GetMenuTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetMenuTree(ctx, req.(*MenuQueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetUserMenuList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetUserMenuList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Menu/GetUserMenuList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetUserMenuList(ctx, req.(*UserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetMenuForRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PermsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetMenuForRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Menu/GetMenuForRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetMenuForRole(ctx, req.(*PermsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Menu_ServiceDesc is the grpc.ServiceDesc for Menu service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Menu_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "koala.Menu",
	HandlerType: (*MenuServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMenu",
			Handler:    _Menu_CreateMenu_Handler,
		},
		{
			MethodName: "UpdateMenu",
			Handler:    _Menu_UpdateMenu_Handler,
		},
		{
			MethodName: "DeleteMenus",
			Handler:    _Menu_DeleteMenus_Handler,
		},
		{
			MethodName: "GetMenuTree",
			Handler:    _Menu_GetMenuTree_Handler,
		},
		{
			MethodName: "GetUserMenuList",
			Handler:    _Menu_GetUserMenuList_Handler,
		},
		{
			MethodName: "GetMenuForRole",
			Handler:    _Menu_GetMenuForRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "koala.proto",
}

// RoleClient is the client API for Role service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleClient interface {
	CreateRole(ctx context.Context, in *RoleReq, opts ...grpc.CallOption) (*EmptyResp, error)
	UpdateRole(ctx context.Context, in *RoleReq, opts ...grpc.CallOption) (*EmptyResp, error)
	DeleteRole(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error)
	PageRole(ctx context.Context, in *RoleQueryReq, opts ...grpc.CallOption) (*RoleListResp, error)
}

type roleClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleClient(cc grpc.ClientConnInterface) RoleClient {
	return &roleClient{cc}
}

func (c *roleClient) CreateRole(ctx context.Context, in *RoleReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Role/CreateRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) UpdateRole(ctx context.Context, in *RoleReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Role/UpdateRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) DeleteRole(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Role/DeleteRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) PageRole(ctx context.Context, in *RoleQueryReq, opts ...grpc.CallOption) (*RoleListResp, error) {
	out := new(RoleListResp)
	err := c.cc.Invoke(ctx, "/koala.Role/PageRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServer is the server API for Role service.
// All implementations must embed UnimplementedRoleServer
// for forward compatibility
type RoleServer interface {
	CreateRole(context.Context, *RoleReq) (*EmptyResp, error)
	UpdateRole(context.Context, *RoleReq) (*EmptyResp, error)
	DeleteRole(context.Context, *DeletesReq) (*EmptyResp, error)
	PageRole(context.Context, *RoleQueryReq) (*RoleListResp, error)
	mustEmbedUnimplementedRoleServer()
}

// UnimplementedRoleServer must be embedded to have forward compatible implementations.
type UnimplementedRoleServer struct {
}

func (UnimplementedRoleServer) CreateRole(context.Context, *RoleReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRole not implemented")
}
func (UnimplementedRoleServer) UpdateRole(context.Context, *RoleReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRole not implemented")
}
func (UnimplementedRoleServer) DeleteRole(context.Context, *DeletesReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (UnimplementedRoleServer) PageRole(context.Context, *RoleQueryReq) (*RoleListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PageRole not implemented")
}
func (UnimplementedRoleServer) mustEmbedUnimplementedRoleServer() {}

// UnsafeRoleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServer will
// result in compilation errors.
type UnsafeRoleServer interface {
	mustEmbedUnimplementedRoleServer()
}

func RegisterRoleServer(s grpc.ServiceRegistrar, srv RoleServer) {
	s.RegisterService(&Role_ServiceDesc, srv)
}

func _Role_CreateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).CreateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Role/CreateRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).CreateRole(ctx, req.(*RoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).UpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Role/UpdateRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).UpdateRole(ctx, req.(*RoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Role/DeleteRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).DeleteRole(ctx, req.(*DeletesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_PageRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleQueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).PageRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Role/PageRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).PageRole(ctx, req.(*RoleQueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Role_ServiceDesc is the grpc.ServiceDesc for Role service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Role_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "koala.Role",
	HandlerType: (*RoleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRole",
			Handler:    _Role_CreateRole_Handler,
		},
		{
			MethodName: "UpdateRole",
			Handler:    _Role_UpdateRole_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _Role_DeleteRole_Handler,
		},
		{
			MethodName: "PageRole",
			Handler:    _Role_PageRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "koala.proto",
}

// DeptClient is the client API for Dept service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeptClient interface {
	CreateDept(ctx context.Context, in *DeptReq, opts ...grpc.CallOption) (*EmptyResp, error)
	UpdateDept(ctx context.Context, in *DeptReq, opts ...grpc.CallOption) (*EmptyResp, error)
	DeleteDept(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error)
	PageDept(ctx context.Context, in *DeptQueryReq, opts ...grpc.CallOption) (*DeptListResp, error)
}

type deptClient struct {
	cc grpc.ClientConnInterface
}

func NewDeptClient(cc grpc.ClientConnInterface) DeptClient {
	return &deptClient{cc}
}

func (c *deptClient) CreateDept(ctx context.Context, in *DeptReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Dept/CreateDept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deptClient) UpdateDept(ctx context.Context, in *DeptReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Dept/UpdateDept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deptClient) DeleteDept(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Dept/DeleteDept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deptClient) PageDept(ctx context.Context, in *DeptQueryReq, opts ...grpc.CallOption) (*DeptListResp, error) {
	out := new(DeptListResp)
	err := c.cc.Invoke(ctx, "/koala.Dept/PageDept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeptServer is the server API for Dept service.
// All implementations must embed UnimplementedDeptServer
// for forward compatibility
type DeptServer interface {
	CreateDept(context.Context, *DeptReq) (*EmptyResp, error)
	UpdateDept(context.Context, *DeptReq) (*EmptyResp, error)
	DeleteDept(context.Context, *DeletesReq) (*EmptyResp, error)
	PageDept(context.Context, *DeptQueryReq) (*DeptListResp, error)
	mustEmbedUnimplementedDeptServer()
}

// UnimplementedDeptServer must be embedded to have forward compatible implementations.
type UnimplementedDeptServer struct {
}

func (UnimplementedDeptServer) CreateDept(context.Context, *DeptReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDept not implemented")
}
func (UnimplementedDeptServer) UpdateDept(context.Context, *DeptReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDept not implemented")
}
func (UnimplementedDeptServer) DeleteDept(context.Context, *DeletesReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDept not implemented")
}
func (UnimplementedDeptServer) PageDept(context.Context, *DeptQueryReq) (*DeptListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PageDept not implemented")
}
func (UnimplementedDeptServer) mustEmbedUnimplementedDeptServer() {}

// UnsafeDeptServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeptServer will
// result in compilation errors.
type UnsafeDeptServer interface {
	mustEmbedUnimplementedDeptServer()
}

func RegisterDeptServer(s grpc.ServiceRegistrar, srv DeptServer) {
	s.RegisterService(&Dept_ServiceDesc, srv)
}

func _Dept_CreateDept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeptServer).CreateDept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Dept/CreateDept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeptServer).CreateDept(ctx, req.(*DeptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dept_UpdateDept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeptServer).UpdateDept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Dept/UpdateDept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeptServer).UpdateDept(ctx, req.(*DeptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dept_DeleteDept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeptServer).DeleteDept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Dept/DeleteDept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeptServer).DeleteDept(ctx, req.(*DeletesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dept_PageDept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeptQueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeptServer).PageDept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Dept/PageDept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeptServer).PageDept(ctx, req.(*DeptQueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Dept_ServiceDesc is the grpc.ServiceDesc for Dept service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Dept_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "koala.Dept",
	HandlerType: (*DeptServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDept",
			Handler:    _Dept_CreateDept_Handler,
		},
		{
			MethodName: "UpdateDept",
			Handler:    _Dept_UpdateDept_Handler,
		},
		{
			MethodName: "DeleteDept",
			Handler:    _Dept_DeleteDept_Handler,
		},
		{
			MethodName: "PageDept",
			Handler:    _Dept_PageDept_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "koala.proto",
}

// PostClient is the client API for Post service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PostClient interface {
	CreatePost(ctx context.Context, in *PostReq, opts ...grpc.CallOption) (*EmptyResp, error)
	UpdatePost(ctx context.Context, in *PostReq, opts ...grpc.CallOption) (*EmptyResp, error)
	DeletePost(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error)
	PagePost(ctx context.Context, in *PostQueryReq, opts ...grpc.CallOption) (*PostListResp, error)
}

type postClient struct {
	cc grpc.ClientConnInterface
}

func NewPostClient(cc grpc.ClientConnInterface) PostClient {
	return &postClient{cc}
}

func (c *postClient) CreatePost(ctx context.Context, in *PostReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Post/CreatePost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postClient) UpdatePost(ctx context.Context, in *PostReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Post/UpdatePost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postClient) DeletePost(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Post/DeletePost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postClient) PagePost(ctx context.Context, in *PostQueryReq, opts ...grpc.CallOption) (*PostListResp, error) {
	out := new(PostListResp)
	err := c.cc.Invoke(ctx, "/koala.Post/PagePost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PostServer is the server API for Post service.
// All implementations must embed UnimplementedPostServer
// for forward compatibility
type PostServer interface {
	CreatePost(context.Context, *PostReq) (*EmptyResp, error)
	UpdatePost(context.Context, *PostReq) (*EmptyResp, error)
	DeletePost(context.Context, *DeletesReq) (*EmptyResp, error)
	PagePost(context.Context, *PostQueryReq) (*PostListResp, error)
	mustEmbedUnimplementedPostServer()
}

// UnimplementedPostServer must be embedded to have forward compatible implementations.
type UnimplementedPostServer struct {
}

func (UnimplementedPostServer) CreatePost(context.Context, *PostReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePost not implemented")
}
func (UnimplementedPostServer) UpdatePost(context.Context, *PostReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePost not implemented")
}
func (UnimplementedPostServer) DeletePost(context.Context, *DeletesReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePost not implemented")
}
func (UnimplementedPostServer) PagePost(context.Context, *PostQueryReq) (*PostListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PagePost not implemented")
}
func (UnimplementedPostServer) mustEmbedUnimplementedPostServer() {}

// UnsafePostServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PostServer will
// result in compilation errors.
type UnsafePostServer interface {
	mustEmbedUnimplementedPostServer()
}

func RegisterPostServer(s grpc.ServiceRegistrar, srv PostServer) {
	s.RegisterService(&Post_ServiceDesc, srv)
}

func _Post_CreatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostServer).CreatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Post/CreatePost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostServer).CreatePost(ctx, req.(*PostReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Post_UpdatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostServer).UpdatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Post/UpdatePost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostServer).UpdatePost(ctx, req.(*PostReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Post_DeletePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostServer).DeletePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Post/DeletePost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostServer).DeletePost(ctx, req.(*DeletesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Post_PagePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostQueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostServer).PagePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Post/PagePost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostServer).PagePost(ctx, req.(*PostQueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Post_ServiceDesc is the grpc.ServiceDesc for Post service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Post_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "koala.Post",
	HandlerType: (*PostServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePost",
			Handler:    _Post_CreatePost_Handler,
		},
		{
			MethodName: "UpdatePost",
			Handler:    _Post_UpdatePost_Handler,
		},
		{
			MethodName: "DeletePost",
			Handler:    _Post_DeletePost_Handler,
		},
		{
			MethodName: "PagePost",
			Handler:    _Post_PagePost_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "koala.proto",
}

// ApiClient is the client API for Api service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiClient interface {
	CreateApi(ctx context.Context, in *ApiReq, opts ...grpc.CallOption) (*EmptyResp, error)
	UpdateApi(ctx context.Context, in *ApiReq, opts ...grpc.CallOption) (*EmptyResp, error)
	DeleteApi(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error)
	PageApi(ctx context.Context, in *ApiQueryReq, opts ...grpc.CallOption) (*ApiListResp, error)
}

type apiClient struct {
	cc grpc.ClientConnInterface
}

func NewApiClient(cc grpc.ClientConnInterface) ApiClient {
	return &apiClient{cc}
}

func (c *apiClient) CreateApi(ctx context.Context, in *ApiReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Api/CreateApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) UpdateApi(ctx context.Context, in *ApiReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Api/UpdateApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) DeleteApi(ctx context.Context, in *DeletesReq, opts ...grpc.CallOption) (*EmptyResp, error) {
	out := new(EmptyResp)
	err := c.cc.Invoke(ctx, "/koala.Api/DeleteApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) PageApi(ctx context.Context, in *ApiQueryReq, opts ...grpc.CallOption) (*ApiListResp, error) {
	out := new(ApiListResp)
	err := c.cc.Invoke(ctx, "/koala.Api/PageApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiServer is the server API for Api service.
// All implementations must embed UnimplementedApiServer
// for forward compatibility
type ApiServer interface {
	CreateApi(context.Context, *ApiReq) (*EmptyResp, error)
	UpdateApi(context.Context, *ApiReq) (*EmptyResp, error)
	DeleteApi(context.Context, *DeletesReq) (*EmptyResp, error)
	PageApi(context.Context, *ApiQueryReq) (*ApiListResp, error)
	mustEmbedUnimplementedApiServer()
}

// UnimplementedApiServer must be embedded to have forward compatible implementations.
type UnimplementedApiServer struct {
}

func (UnimplementedApiServer) CreateApi(context.Context, *ApiReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateApi not implemented")
}
func (UnimplementedApiServer) UpdateApi(context.Context, *ApiReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateApi not implemented")
}
func (UnimplementedApiServer) DeleteApi(context.Context, *DeletesReq) (*EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApi not implemented")
}
func (UnimplementedApiServer) PageApi(context.Context, *ApiQueryReq) (*ApiListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PageApi not implemented")
}
func (UnimplementedApiServer) mustEmbedUnimplementedApiServer() {}

// UnsafeApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiServer will
// result in compilation errors.
type UnsafeApiServer interface {
	mustEmbedUnimplementedApiServer()
}

func RegisterApiServer(s grpc.ServiceRegistrar, srv ApiServer) {
	s.RegisterService(&Api_ServiceDesc, srv)
}

func _Api_CreateApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).CreateApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Api/CreateApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).CreateApi(ctx, req.(*ApiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_UpdateApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).UpdateApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Api/UpdateApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).UpdateApi(ctx, req.(*ApiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_DeleteApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).DeleteApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Api/DeleteApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).DeleteApi(ctx, req.(*DeletesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_PageApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiQueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).PageApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/koala.Api/PageApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).PageApi(ctx, req.(*ApiQueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Api_ServiceDesc is the grpc.ServiceDesc for Api service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Api_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "koala.Api",
	HandlerType: (*ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateApi",
			Handler:    _Api_CreateApi_Handler,
		},
		{
			MethodName: "UpdateApi",
			Handler:    _Api_UpdateApi_Handler,
		},
		{
			MethodName: "DeleteApi",
			Handler:    _Api_DeleteApi_Handler,
		},
		{
			MethodName: "PageApi",
			Handler:    _Api_PageApi_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "koala.proto",
}
